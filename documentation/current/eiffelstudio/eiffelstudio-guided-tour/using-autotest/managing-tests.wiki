[[Property:title|Managing tests]]
[[Property:weight|9]]
[[Property:uuid|f1e7f63a-dc86-fefb-e669-3e3ea178c596]]
{{underconstruction}}


The previous sections cover the basics of testing and what it takes to create and use each of the test types supported by the Eiffel Testing Framework. This section will finish things up with some miscellaneous information about testing strategy and hints on using of the Framework.



==Favor manual tests==


It is worth repeating that currently, manual tests should form the majority of your testing suite. As you have seen, extracted and synthesized tests use more complex setup and execution mechanisms. These mechanisms make tests less robust and readable than manual tests. So using extracted and synthesized tests as a guide to produce manual tests with the same coverage is, at this time, the best way to work. You will probably be able to do this easily enough with synthesized tests. Extracted tests attempt to recreate the context at a specific point in time, which may make it more difficult to write a manual test that is equivalent an extracted test. 

Because manual tests are more easily readable than either of the automatically generated test types, you should be able to understand more quickly what has happened when a test produces failing results.


==Deleting uneeded tests==


At some point and for various reasons, you will probably want to delete tests from your test suite. This is easy enough to do. Remember that test sets are actually just classes with certain characteristics, and that tests are actually just specialized routines of test classes. 

If you want to delete a single test, you can delete that feature from its test class. 

If you want to remove a whole test set, then [[Removing a class|delete the class]] that defines that test set.


==Using Views and Filters==

Views and Filters are provided to help view, manage, and run the tests in a test suite. 

Views control ''how'' the view of tests is organized in the Eiffel Testing Framework interface. You can display tests organized by the test classes that contain them, by the classes they target, by their type, by their most recent results, or by any system you set up using a system of [[Create a manual test#About tags|tags]]. 

Filters control ''which'' tests are displayed in the Eiffel Testing Framework interface. 

===The View box===

The View box on the Eiffel Testing Framework can be used to display tests by different criteria. However, the workings of the View box deserve some explanation. If you just try to use View without any background knowledge, you may find it non-intuitive. 

It is important to bear in mind that the View box works with the system of [[Create a manual test#About tags|tags]] described in the section on creating manual tests. Tags are hierarchically structured names that are applied to tests through the <code>note</code> clause. When you use the View box to display a set of tests, you specify that set by the tags on the tests. Some of the tags are implicit, in the sense that the Testing Framework accounts for them, and they are not explicitly coded in <code>note</code> clauses. This should become clear when we look at some examples.

When the View box is displaying a set of tests, the "root" tag(s) for the sub tree of tests is what is visible in the View box. Let's look at some examples.

If the view box is empty, it will display tests accessible through all root tags. So, using the example we built in the preceding sections, if we just select the blank choice for the View box, here's what we see:


[[Image:Testing Framework interface View box 01]]


In the column labeled '''Tests''', you see tree view root words '''class''', '''covers''', '''outcome''', and '''type'''. The view labeled '''class''' means ''"tests as they are structured in their test classes."'' So, if we completely expand '''class''' for our test system, then in the '''Tests''' column we see:


[[Image:Testing Framework interface View box 02]]


The '''covers''' tag root means ''"tests based on their target classes and target routines."'' 


[[Image:Testing Framework interface View box 03]]


This shows that there is only one target class <code>BANK_ACCOUNT</code>, and two of its routines are target routines, <code>deposit</code> and <code>withdraw</code>.

The '''outcome''' tag root means ''"tests categorized by whether they were successful or failing in the most recent run."'' So expanding '''outcome''' we see that all of out tests show up as successful:


[[Image:Testing Framework interface View box 04]]


The '''type''' tag root means ''"tests categorized by type."'' So, if we expand '''types''', we see our tests grouped by '''extracted''', '''generated''' (synthesized), and '''manual''':


[[Image:Testing Framework interface View box 05]]



{{note|The tag roots will appear only if there are tests that can be categorized under them. For example, if you have not run any tests, then '''outcome''' will not appear. }}


Notice that the View box has a list of options: 


[[Image:Testing Framework interface View box 06]]


These options are shortcuts to the various tag roots that we just discussed: 

#'''Tests''' displays the sub-tree under the tag root '''class'''
#'''Results''' displays the sub-tree under the tag root '''outcome'''
#'''Classes under test''' displays the sub-tree under the tag root '''covers'''
#'''Types''' displays the sub-tree under the tag root '''type'''


Any tagging system that you devise will also show up in the View box. Let's edit our tests and add an additional line of testing information to each with some arbitrary hierarchical tags.

So, now the manual test now looks like this:

<code>
    test_deposit_01
            -- New test routine
        note
            testing:  "covers/{BANK_ACCOUNT}.deposit"
            testing:  "my_tag_1/my_tag_1_1/my_tag_1_1_1"
        local
            l_ba: BANK_ACCOUNT
        do
            create l_ba
            l_ba.deposit (500)
        end
</code>

In the extracted test targeting <code>{BANK_ACCOUNT}.withdraw</code> this line has been added:
<code>
            testing: "my_tag_1/my_tag_1_1/my_tag_1_1_2"
</code>
and in the synthesized test which targets <code>{BANK_ACCOUNT}.withdraw</code> we add this line:
<code>
           testing: "my_tag_1/my_tag_1_2/my_tag_1_2_1"
</code>
As soon as we compile and set the View box to blank to show all tag roots, we see that the root for our new tag root shows up in the list: 


[[Image:Testing Framework interface View box 07]]


If we expand the tag root '''my_tag_1''' completely, we see our tests arranged according to their values for this tag root:


[[Image:Testing Framework interface View box 08]]




