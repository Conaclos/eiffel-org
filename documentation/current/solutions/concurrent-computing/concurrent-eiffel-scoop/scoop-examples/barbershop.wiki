[[Property:title|Barbershop]]
[[Property:weight|-11]]
[[Property:uuid|3a6f929f-17a2-c9d8-1b88-0aad83db4160]]
{{UnderConstruction}}


{{Beta}}


=Description=

The [http://en.wikipedia.org/wiki/Sleeping_barber_problem barbershop], sometimes called ''the sleeping barber'', models a barbershop with one barber, one barber's chair, and a waiting room with several chairs. The alternative name of the problem comes from the fact that if there is no one waiting for a haircut, the barber flops in his chair and falls asleep. 

Also involved are a number of shaggy-haired customers. A customer entering the barbershop looks around and assesses the situation. If all the waiting room chairs are occupied, the customer leaves the shop to return again at a time when hopefully the queue will be shorter. If there is an open chair the customer sits down and waits for the barber.

Once the barber has finished cutting a customer's hair, the customer leaves the shop which allows another customer to enter the shop (if all the chairs had been occupied) and the the next customer (if there is one) in the queue to get a haircut.

In this example, even after getting their hair cut, the customers come back to the shop until they have had their hair cut some prescribed number of times.


=Highlights=

The example contains classes that model the barber (<code>BARBER</code>), the customers (<code>CUSTOMER</code>), and the shop with its waiting area (<code>SHOP</code>). The root class creates as separate objects the barber, the shop, and the set of customers. As each customer is created, it is launched on its lifecycle of getting haircut after haircut until haircuts are no longer needed.

The <code>SHOP</code> includes features <code>enter</code> and <code>leave</code>. Customers call the <code>enter</code> feature to find out if there is a chair available in the shop. Customers call <code>leave</code>, after their hair has been cut. Both of these calls are "wrapped" as separate calls in the class <code>CUSTOMER</code>.

A typical customer lives in this way: As long as he still needs haircuts, he repeatedly does the following steps: He tries to enter the shop. If he's unsuccessful because all the chairs are occupied, he goes off for a while (in the implementation, his processor sleeps and then comes to the end of this step). If he is able to enter the shop, then he puts himself in the queue for a haircut. Once his haircut is complete, he reduces his number of haircuts needed by one, and leaves the shop.

One thing that you might find curious about this example is the feature <code>do_hair_cut</code> in class <code>BARBER</code>. This feature is called by a customer when the barber becomes available to cut the customer's hair. <code>do_hair_cut</code> is a function that returns a <code>BOOLEAN</code>. If you look at the source code for <code>do_hair_cut</code>, you'll see that the routine cannot complete with any result other than <code>True</code> ... and this may seem odd. 

<code>
    do_hair_cut (an_id: INTEGER): BOOLEAN
            -- Called from a customer who wants to get hair cut
        require
            an_id >= 0
        do
            (create {EXECUTION_ENVIRONMENT}).sleep (hair_cut_time * 1000000)
            result := true
        end
</code>

Couldn't a function that always returns the exact same predictable result be safely made a procedure? Certainly it could. However, there is a SCOOP oriented reason for this routine being a function rather than a procedure. 

<code>{BARBER}.do_hair_cut</code> is a function in order to become synchronous. Remember that a [[Concurrent Eiffel with SCOOP#Separate types and separate calls|separate call]] which is a query is always a [[Concurrent Eiffel with SCOOP#Synchronous and asynchronous feature calls|synchronous call. In the case of the customer, he needs to leave the shop only after his haircut is complete. Therefore, the query <code>do_hair_cut</code> will be synchronous and ensure that the haircut is complete before the customer leaves the shop.




