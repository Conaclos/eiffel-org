[[Property:title|SCOOP implementation]]
[[Property:weight|2]]
[[Property:uuid|eeb07907-e036-f3d6-5297-a7c44cfd1900]]
{{UnderConstruction}}


The implementation of SCOOP within EiffelStudio varies from the definition as it has been presented in publications during the model's evolution. 

Some of the differences stem from the reality that SCOOP systems could be optimized for performance, including maximizing concurrency. For example, even though the SCOOP rules state that a separate call to a query is synchronous, i. e., the calling processor waits until the query completes before proceeding, if a static analysis can show that the wait is not necessary to the proper functioning of the remainder of the calling routine, then the call to the query can be done asynchronously. 

In other ways, particularly for early versions, the EiffelStudio implementation may not cover all the goals of SCOOP as stated in the various publications. Certain elements that are defined in the SCOOP descriptions may not yet be present, or only partially implemented in the EiffelStudio implementation.  

The differences between the EiffelStudio implementation of SCOOP and current and previous definitions of the SCOOP model are shown below.


=Known limitations=

==Separate anchored types==

Applicable to version 6.8, prior to revision number 86657. 

Separate status for anchored types is not supported properly. So declarations of the form:

<code>
            my_entity: separate like my_query
</code>
 
and

<code>
            my_entity: separate like Current
</code>

should be used only if you are using revision 86657 or later. 

Also, if you use an anchored declaration such as:

<code>
            my_entity: like my_query
</code>

and the type of <code>my_query</code> is <code>separate</code>, you should make sure you are using revision 86657 or later.


=Implementation dependent behavior=

==The Wait Rule==

The [[Concurrent Eiffel with SCOOP#Access to shared resources|Wait Rule]] says: ''A routine call with separate arguments will execute when all corresponding processors are available and hold them exclusively for the duration of the routine.''

In the EiffelStudio implementation, a routine will not necessarily wait for all processors associated with its separate arguments to be available before it ''begins'' execution. The waiting on processors occurs in a "lazy" manner. Execution will only wait on the availability of one of the processors when it actually needs to use the argument associated with that processor. This means that if there are several instructions ahead of the first instruction that references a separate argument, then those several instructions will be executed immediately. Only at the point at which the separate argument's processor is needed will the routine pause and wait for the availability of the processor.





